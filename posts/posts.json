[
  {
    "path": "posts/2020-11-27-what-is-interoperability/",
    "title": "What is interoperability?",
    "description": "Here, I give a short introduction to interoperability and why I think we should make an effort for it.\n\n\nTL;DR: Many functions have very context-specific side-effects making code harder to understand and less exchangeable. Try using interoperable functions wherever you can!",
    "author": [
      {
        "name": "Steffen Ehrmann",
        "url": {}
      }
    ],
    "date": "2024-04-17",
    "categories": [
      "interoperability",
      "why though",
      "R"
    ],
    "contents": "\r\n\r\nContents\r\nRationale\r\nSelect a column in a data frame\r\n\"Like a matrix\"\r\nSelect columns by name\r\nSumming up\r\n\r\nRationale\r\nIn the last months and years, it became increasingly evident to me that I have an obsession with interoperability.\r\nAt first, I didn’t know it’s called like that or what it even means, but the idea was there already.\r\nSo what is interoperability then?\r\n\r\n“Interoperability is a characteristic of a product or system, whose interfaces are completely understood, to work with other products or systems, present or future, in either implementation or access, without any restrictions.” 1\r\n\r\nInteroperable software, for instance, is designed to efficiently exchange information with other software by providing the output of functionally similar (or the same) operations in a common arrangement or format, standardising access to the resulting data.\r\nThis principle is not only true for software written in different programming languages, but can also apply to several packages, or workflows, within the R ecosystem.\r\nWhat was visible to me, back in the time, was a wave of standardisation of workflows and software, for example, the R package dplyr.\r\ndplyr provides a relatively small set of \"verbs\" as the basic building blocks (I would call them operators) to build various data management algorithms.\r\nI would regard these operators as interoperable software because they are the result of identifying those aspects many workflows have in common.\r\nEventually they are a harmonised and easy to understand interface to access and process data.\r\nA typical example would be to calculate the average of a set of values for the levels of a factor.\r\nThis task is composed of two subtasks:\r\ngrouping the values according to the levels,\r\ncalculating the average for each group.\r\nWhile the base R function table() carries out the task in one go, the functions dplyr functions group_by() and summarise() do the same thing, but more explicitly 2.\r\nExceptions to an otherwise well-defined operator are not available as a standalone function. Instead, the correct building blocks have to be combined to end up with the desired result, and this is what ultimately results in more interoperability.\r\nIt is crystal clear what any workflow means, in terms of the combination of well-understood operators.\r\nMoreover, the \"algorithms\" resulting from this are understandable at a more human-readable level.\r\nThey could be implemented in a very similar way also in other programming languages, in case the same operators (with the same functional meaning) are available in those languages.\r\nWhile dplyr may be consistent in itself about the individual tasks each function solves, this starts looking different when taking the whole R ecosystem into account.\r\nHere, many functions carry out the same or a similar task, and many tasks can be carried out with several functions.\r\nHowever, some functions have been well designed (with a clear and unique use-case in mind), and other functions can be used in many different ways, depending on the context.\r\nSelect a column in a data frame\r\nTo exemplify where non-interoperable software might become problematic, I want to select a column from a data frame (simple, right?).\r\nAnybody who started using R before dplyr or the tidyverse would suggest to \"simply use that bracket function\".\r\nSome witty people would even suggest using $, because \"it’s cool\", so let’s also think about that.\r\nSpoiler: [ and [[ are actually different functions, and also using a ',' or not results in functionally different behaviour.\r\nWhat is the difference between [ and [[?\r\nWell, their documentation states that [ can select more than one element, whereas the other selects only a single element.\r\nAlso $ selects only a single element, but due to the way it is invoked, this seems rather obvious.\r\nLet’s first look at [.\r\n\r\n\r\ndf <- data.frame(num = c(1, 2, 3, 4),\r\n                 char = LETTERS[1:4],\r\n                 bool = c(F, T, T, F), \r\n                 stringsAsFactors = FALSE)\r\n\r\n# select columns by index; the first and second column\r\ndf[, c(1, 2)]                   \r\n\r\n  num char\r\n1   1    A\r\n2   2    B\r\n3   3    C\r\n4   4    D\r\n\r\n# select columns by name\r\ndf[, c(\"num\", \"char\")]          \r\n\r\n  num char\r\n1   1    A\r\n2   2    B\r\n3   3    C\r\n4   4    D\r\n\r\n# selecting only one column with the same notation results in a different output format ...\r\ndf[, 1]\r\n\r\n[1] 1 2 3 4\r\n\r\n# ... except when using additional arguments (wait what... that's possible?)\r\ndf[, 1, drop = FALSE]\r\n\r\n  num\r\n1   1\r\n2   2\r\n3   3\r\n4   4\r\n\r\n# using the [[ function that has been intended for selecting single element, we\r\n# also only get the values, and not the whole column\r\ndf[[1]]\r\n\r\n[1] 1 2 3 4\r\n\r\nWith this simple test, I gained the insight that [ is by default not a function that has been designed for an interoperable workflow without any restrictions.\r\nWhen providing only a single value to [, I don’t receive a column (which would imply that the output format is a data frame), but a vector of the contents of a column.\r\nI can’t use this function in any context, where it is not previously known how many columns I will have to select, without first running additional tests to inquire about the context (as in the following hypothetical function).\r\n\r\n\r\nmySelect <- function(df, row, cols){\r\n  if(length(cols) > 1){\r\n    df[row, cols]               # here the default is sufficient\r\n  } else {\r\n    df[row, cols, drop = FALSE] # but in this case I require the additional argument \r\n  }\r\n}\r\n\r\n\r\nAs I could simply use the drop = FALSE argument all the time, this lack of interoperability may not look like a big deal right now.\r\nThe example nevertheless underpins the point that if I use the default of this function, the format of the output I get from this particular operation depends on my input case (whether I need to select one or more columns).\r\nI would argue that it is a big deal.\r\nWe always have to bear in mind that a program only knows what we tell it to know.\r\nWhen we tell our program or expect by implication 3 that a downstream function requires a data frame with column names, that function will not be able to proceed when it gets a numeric vector instead.\r\n\"Like a matrix\"\r\nMoreover, to understand both [ and [[, we also need to know that we can index a data frame \"like a matrix\" using a ','.\r\nWe would signal that either rows (anything before the comma), columns (anything behind the comma), or a single cell (both positions) are selected.\r\nThat indexing like a matrix-statement presumably only makes sense when its clear that a data frame is, in fact, a special case of a list, so that indexing like a matrix is not the first thing to think about when indexing a data frame.\r\nThat case is characterised by only one level of nesting, the same amount of elements per list-item and with a specific way of being printed in the console.\r\nSo the other case of indexing a data frame (next to like a matrix, i.e., with ',') is indexing it like a list (i.e., without ',').\r\nWhen indexing like a list, it makes sense that no comma is involved, because this is how we treat lists.\r\n\r\n\r\nlst <- list(num = c(1, 2, 3, 4),\r\n            char = LETTERS[1:4], \r\n            bool = c(F, T, T, F))\r\n\r\n# get element with its name\r\nlst[1]\r\n\r\n$num\r\n[1] 1 2 3 4\r\n\r\ndf[1]\r\n\r\n  num\r\n1   1\r\n2   2\r\n3   3\r\n4   4\r\n\r\n# get only the values\r\nlst[[1]]\r\n\r\n[1] 1 2 3 4\r\n\r\ndf[[1]]\r\n\r\n[1] 1 2 3 4\r\n\r\nIn the documentation, there is no clear statement that indexing like a matrix and indexing like a list are different functions.\r\nThus I find it most intuitive to assume that \"omitting the ','\" is like choosing the first argument of the function call, as this the same behaviour as in any other function in R.\r\nHowever, you have guessed it, this is not how [ works with the comma-notation because columns are specified after the comma.\r\n\r\n\r\n# indexing like a list\r\ndf[1]\r\n\r\n  num\r\n1   1\r\n2   2\r\n3   3\r\n4   4\r\n\r\n# indexing naively (like a matrix)\r\ndf[1, ]\r\n\r\n  num char  bool\r\n1   1    A FALSE\r\n\r\n# actually indexing like a matrix and keeping the name\r\ndf[, 1, drop = FALSE]\r\n\r\n  num\r\n1   1\r\n2   2\r\n3   3\r\n4   4\r\n\r\nOne could say [ is not even interoperable with itself (depending on how the arguments are specified)!?\r\nI am aware that this example is very artificial and anybody who has understood how \"the comma-notation\" works should be able to avoid that pitfall.\r\nStill, the fact that it even exists is another testimony of a lack of interoperability.\r\nI touched on it above already, assuming it’s the same function might be the problem here.\r\nPerhaps we should simply not regard [ as the same function as [,, or not even as a special case of it – because their arguments contradict one another.\r\nSelect columns by name\r\nThe previous two issues are not even where the lack of interoperability ends or could conclusively be dealt with. When we want to select a column by its name, we can do that with both [ and [[.\r\nHowever, in case we were that witty person using $, we might get into trouble latest here.\r\nSome things are unknown at the time a function is built, such as the column names of data frames the user provides.\r\nThus, a function that is supposed to work with such dynamic data has to be compatible with unknown column names.\r\n\r\n\r\n# select any column that is specified or determined elsewhere in a script or function\r\nmyColumn <- \"num\"\r\n\r\ndf[myColumn]\r\n\r\n  num\r\n1   1\r\n2   2\r\n3   3\r\n4   4\r\n\r\ndf[[myColumn]]\r\n\r\n[1] 1 2 3 4\r\n\r\ndf$myColumn                   # bummer!\r\n\r\nNULL\r\n\r\nWith this additional test, I learned that not all the \"traditional\" functions of the select operation could even handle the same input in the first place.\r\nThis also hampers interoperability.\r\nIn case I decide to use the $ function, I can only do this where:\r\nI am certain that a single column is selected,\r\nthat column definitely exists in the data-frame and\r\nI want the output as a vector without name.\r\nGranted, in (some/many/most) cases this may be sufficient, depending on your use-cases.\r\nHowever, I would argue, here again, the code must be provided with routines that ensure all requirements are met (i.e., made interoperable), before being able to successfully proceed.\r\nSumming up\r\nThere are several ways of selecting a column from a data frame, some of which are more or less context-specific and thus not interoperable (in the sense of interchangeable).\r\n\r\n\r\n# get the values as column in a data-frame\r\ndf[\"num\"]\r\ndf[, \"num\", drop = FALSE]\r\ndf[myColumn]\r\n\r\n# get the values as vector\r\ndf[, \"num\"]\r\ndf[[\"num\"]]\r\ndf$num\r\n\r\n\r\nSuppose you choose to go for the \"traditional way\" of coding with those functions.\r\nIn that case, the result is almost certainly a rather complex code that potentially requires a lot of time allocated to debugging.\r\nWhen you instead use modern, more interoperable functions, you can allocated more time to building an algorithm instead of managing implicit assumptions of data formats.\r\n\r\nPerhaps at this stage you don’t believe that you even need to manage implicit assumption, but I will write also a \"why though\" blog post on this some time in the future!\r\n\r\n\r\nlibrary(dplyr)\r\n\r\n# select the column ...\r\nselect(df, num)\r\n\r\n  num\r\n1   1\r\n2   2\r\n3   3\r\n4   4\r\n\r\n# ... or pull its values\r\npull(df, num)\r\n\r\n[1] 1 2 3 4\r\n\r\nInteroperability can have many faces and can be interpreted from different perspectives; the one I complained about here is only one.\r\nWhile [ might have some problematic aspects (which seem to be mostly due to its implementation of indexing like a matrix), it is itself an attempt at making code more interoperable.\r\nThe bracket function exists in many programming languages and typically serves as a tool to index arrays.\r\nAs many objects are stored in arrays, it is thus a frequently used tool to access data or their subsets.\r\nMoreover, also within R, it allows accessing objects of different classes with the same notation.\r\n\r\n\r\nvector <- c(1, 2, 3, 4)\r\n\r\ndf[1]\r\n\r\n  num\r\n1   1\r\n2   2\r\n3   3\r\n4   4\r\n\r\nlst[1]\r\n\r\n$num\r\n[1] 1 2 3 4\r\n\r\nvector[1]\r\n\r\n[1] 1\r\n\r\nIn future blog posts, I will write about other aspects of interoperability, such as semantic interoperability, ontologies, more examples of (non-)interoperable code (such as the geometr package) and other related aspects.\r\n\r\nhttp://interoperability-definition.info/en/↩︎\r\nAs yet another advantage, this procedure also allows calculating summary metrics other than a sum or count↩︎\r\nwhich is the case with most functions and scripts, especially in the R programming language↩︎\r\n",
    "preview": {},
    "last_modified": "2024-04-17T13:34:21+02:00",
    "input_file": {}
  }
]
